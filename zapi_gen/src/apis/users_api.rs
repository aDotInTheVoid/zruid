/*
 * Zulip REST API
 *
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `create_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserError {
    Status400(crate::models::JsonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_user_group`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserGroupError {
    Status400(crate::models::JsonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `deactivate_my_account`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeactivateMyAccountError {
    Status400(crate::models::JsonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `deactivate_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeactivateUserError {
    Status400(crate::models::JsonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_attachments`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAttachmentsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_own_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOwnUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_user_by_email`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserByEmailError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_user_groups`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserGroupsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_user_presence`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserPresenceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_users`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUsersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `reactivate_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactivateUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `remove_user_group`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveUserGroupError {
    Status400(crate::models::JsonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `set_typing_status`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetTypingStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_notification_settings`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateNotificationSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserError {
    Status400(crate::models::CodedError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_user_group`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserGroupError {
    Status400(crate::models::JsonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_user_group_members`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserGroupMembersError {
    UnknownValue(serde_json::Value),
}


/// {!can-create-users-only.md!}  Create a new user account via the API.  `POST {{ api_url }}/v1/users` 
pub async fn create_user(configuration: &configuration::Configuration, email: &str, password: &str, full_name: &str) -> Result<crate::models::JsonSuccessBase, Error<CreateUserError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("email", &email.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("password", &password.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("full_name", &full_name.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/create` 
pub async fn create_user_group(configuration: &configuration::Configuration, name: &str, description: &str, members: Vec<i32>) -> Result<crate::models::JsonSuccess, Error<CreateUserGroupError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/user_groups/create", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("name", &name.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("description", &description.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("members", &members.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateUserGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete the requesting user from the realm. 
pub async fn deactivate_my_account(configuration: &configuration::Configuration, ) -> Result<crate::models::JsonSuccess, Error<DeactivateMyAccountError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/me", configuration.base_path);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeactivateMyAccountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// {!api-admin-only.md!}  [Deactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `DELETE {{ api_url }}/v1/users/{user_id}` 
pub async fn deactivate_user(configuration: &configuration::Configuration, user_id: i32) -> Result<crate::models::JsonSuccess, Error<DeactivateUserError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/{user_id}", configuration.base_path, user_id=user_id);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeactivateUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch metadata on files uploaded by the requesting user.  `GET {{ api_url }}/v1/attachments` 
pub async fn get_attachments(configuration: &configuration::Configuration, ) -> Result<crate::models::JsonSuccessBase, Error<GetAttachmentsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/attachments", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAttachmentsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get basic data about the user/bot that requests this endpoint.  `GET {{ api_url }}/v1/users/me` 
pub async fn get_own_user(configuration: &configuration::Configuration, ) -> Result<crate::models::JsonSuccessBase, Error<GetOwnUserError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/me", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetOwnUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch details for a single user in the organization.  `GET {{ api_url }}/v1/users/{user_id}`  You can also fetch details on [all users in the organization](/api/get-users) or [by email](/api/get-user-by-email).  *This endpoint is new in Zulip Server 3.0 (feature level 1).* 
pub async fn get_user(configuration: &configuration::Configuration, user_id: i32, client_gravatar: Option<bool>, include_custom_profile_fields: Option<bool>) -> Result<crate::models::JsonSuccessBase, Error<GetUserError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/{user_id}", configuration.base_path, user_id=user_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = client_gravatar {
        local_var_req_builder = local_var_req_builder.query(&[("client_gravatar", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_custom_profile_fields {
        local_var_req_builder = local_var_req_builder.query(&[("include_custom_profile_fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch details for a single user in the organization given a Zulip display email address.  `GET {{ api_url }}/v1/users/{email}`  Note that this endpoint uses Zulip display emails addresses for organizations that have configured limited [email address visibility](/help/restrict-visibility-of-email-addresses).  You can also fetch details on [all users in the organization](/api/get-users) or [by user ID](/api/get-user).  Fetching by user ID is generally recommended when possible, as users can [change their email address](/help/change-your-email-address).  *This endpoint is new in Zulip Server 4.0 (feature level 39).* 
pub async fn get_user_by_email(configuration: &configuration::Configuration, email: &str, client_gravatar: Option<bool>, include_custom_profile_fields: Option<bool>) -> Result<crate::models::JsonSuccessBase, Error<GetUserByEmailError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/{email}", configuration.base_path, email=crate::apis::urlencode(email));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = client_gravatar {
        local_var_req_builder = local_var_req_builder.query(&[("client_gravatar", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_custom_profile_fields {
        local_var_req_builder = local_var_req_builder.query(&[("include_custom_profile_fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetUserByEmailError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetches all of the user groups in the organization.  `GET {{ api_url }}/v1/user_groups` 
pub async fn get_user_groups(configuration: &configuration::Configuration, ) -> Result<crate::models::JsonSuccessBase, Error<GetUserGroupsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/user_groups", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetUserGroupsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the presence status for a specific user.  This endpoint is most useful for embedding data about a user's presence status in other sites (E.g. an employee directory).  Full Zulip clients like mobile/desktop apps will want to use the main presence endpoint, which returns data for all active users in the organization, instead.  `GET {{ api_url }}/v1/users/{email}/presence`  See [Zulip's developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/presence.html) for details on the data model for presence in Zulip. 
pub async fn get_user_presence(configuration: &configuration::Configuration, email: &str) -> Result<crate::models::JsonSuccessBase, Error<GetUserPresenceError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/{email}/presence", configuration.base_path, email=crate::apis::urlencode(email));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetUserPresenceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve details on all users in the organization.  Optionally includes values of [custom profile field](/help/add-custom-profile-fields).  `GET {{ api_url }}/v1/users`  You can also [fetch details on a single user](/api/get-user). 
pub async fn get_users(configuration: &configuration::Configuration, client_gravatar: Option<bool>, include_custom_profile_fields: Option<bool>) -> Result<crate::models::JsonSuccessBase, Error<GetUsersError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = client_gravatar {
        local_var_req_builder = local_var_req_builder.query(&[("client_gravatar", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_custom_profile_fields {
        local_var_req_builder = local_var_req_builder.query(&[("include_custom_profile_fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetUsersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// {!api-admin-only.md!}  [Reactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `POST {{ api_url }}/v1/users/{user_id}/reactivate` 
pub async fn reactivate_user(configuration: &configuration::Configuration, user_id: i32) -> Result<crate::models::JsonSuccess, Error<ReactivateUserError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/{user_id}/reactivate", configuration.base_path, user_id=user_id);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReactivateUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a [user group](/help/user-groups).  `DELETE {{ api_url }}/v1/user_groups/{user_group_id}` 
pub async fn remove_user_group(configuration: &configuration::Configuration, user_group_id: i32) -> Result<crate::models::JsonSuccess, Error<RemoveUserGroupError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/user_groups/{user_group_id}", configuration.base_path, user_group_id=user_group_id);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RemoveUserGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Notify other users whether the current user is typing a message.  `POST {{ api_url }}/v1/typing`  Clients implementing Zulip's typing notifications protocol should work as follows:  * Send a request to this endpoint with `op=\"start\"` when a user starts typing   a private message or group private message, and also every   `TYPING_STARTED_WAIT_PERIOD=10` seconds that the user continues to actively type   or otherwise interact with the compose UI (E.g. interacting with the compose box   emoji picker). * Send a request to this endpoint with `op=\"stop\"` when a user pauses using the   compose UI for at least `TYPING_STOPPED_WAIT_PERIOD=5` seconds or cancels   the compose action (if it had previously sent a \"start\" operation for that   compose action). * Start displaying \"Sender is typing\" for a given conversation when the client   receives an `op=\"start\"` event from the [events API](/api/get-events). * Continue displaying \"Sender is typing\" until they receive an `op=\"stop\"` event   from the [events API](/api/get-events) or `TYPING_STARTED_EXPIRY_PERIOD=15`   seconds have passed without a new `op=\"start\"` event for that conversation.  This protocol is designed to allow the server-side typing notifications implementation to be stateless while being resilient; network failures cannot result in a user being incorrectly displayed as perpetually typing.  See [the typing notification docs](https://zulip.readthedocs.io/en/latest/subsystems/typing-indicators.html) for additional design details on Zulip's typing notifications protocol. 
pub async fn set_typing_status(configuration: &configuration::Configuration, op: &str, to: Vec<i32>) -> Result<crate::models::JsonSuccess, Error<SetTypingStatusError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/typing", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("op", &op.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("to", &to.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SetTypingStatusError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint is used to edit the user's global notification settings. See [this endpoint](/api/update-subscription-settings) for per-stream notification settings.  `PATCH {{ api_url }}/v1/settings/notifications` 
pub async fn update_notification_settings(configuration: &configuration::Configuration, enable_stream_desktop_notifications: Option<bool>, enable_stream_email_notifications: Option<bool>, enable_stream_push_notifications: Option<bool>, enable_stream_audible_notifications: Option<bool>, notification_sound: Option<&str>, enable_desktop_notifications: Option<bool>, enable_sounds: Option<bool>, enable_offline_email_notifications: Option<bool>, enable_offline_push_notifications: Option<bool>, enable_online_push_notifications: Option<bool>, enable_digest_emails: Option<bool>, enable_login_emails: Option<bool>, message_content_in_email_notifications: Option<bool>, pm_content_in_desktop_notifications: Option<bool>, wildcard_mentions_notify: Option<bool>, desktop_icon_count_display: Option<i32>, realm_name_in_notifications: Option<bool>, presence_enabled: Option<bool>) -> Result<crate::models::JsonSuccessBase, Error<UpdateNotificationSettingsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/settings/notifications", configuration.base_path);
    let mut local_var_req_builder = local_var_client.patch(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = enable_stream_desktop_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("enable_stream_desktop_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_stream_email_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("enable_stream_email_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_stream_push_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("enable_stream_push_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_stream_audible_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("enable_stream_audible_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = notification_sound {
        local_var_req_builder = local_var_req_builder.query(&[("notification_sound", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_desktop_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("enable_desktop_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_sounds {
        local_var_req_builder = local_var_req_builder.query(&[("enable_sounds", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_offline_email_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("enable_offline_email_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_offline_push_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("enable_offline_push_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_online_push_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("enable_online_push_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_digest_emails {
        local_var_req_builder = local_var_req_builder.query(&[("enable_digest_emails", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_login_emails {
        local_var_req_builder = local_var_req_builder.query(&[("enable_login_emails", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = message_content_in_email_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("message_content_in_email_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pm_content_in_desktop_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("pm_content_in_desktop_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = wildcard_mentions_notify {
        local_var_req_builder = local_var_req_builder.query(&[("wildcard_mentions_notify", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = desktop_icon_count_display {
        local_var_req_builder = local_var_req_builder.query(&[("desktop_icon_count_display", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = realm_name_in_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("realm_name_in_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = presence_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("presence_enabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateNotificationSettingsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// {!api-admin-only.md!}  Administrative endpoint to update the details of another user in the organization.  `PATCH {{ api_url }}/v1/users/{user_id}`  Supports everything an administrator can do to edit details of another user's account, including editing full name, [role](/help/roles-and-permissions), and [custom profile fields](/help/add-custom-profile-fields). 
pub async fn update_user(configuration: &configuration::Configuration, user_id: i32, full_name: Option<&str>, role: Option<i32>, profile_data: Option<Vec<serde_json::Value>>) -> Result<crate::models::JsonSuccess, Error<UpdateUserError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/{user_id}", configuration.base_path, user_id=user_id);
    let mut local_var_req_builder = local_var_client.patch(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = full_name {
        local_var_req_builder = local_var_req_builder.query(&[("full_name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = role {
        local_var_req_builder = local_var_req_builder.query(&[("role", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = profile_data {
        local_var_req_builder = local_var_req_builder.query(&[("profile_data", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update the name or description of a [user group](/help/user-groups).  `PATCH {{ api_url }}/v1/user_groups/{user_group_id}` 
pub async fn update_user_group(configuration: &configuration::Configuration, user_group_id: i32, name: &str, description: &str) -> Result<crate::models::JsonSuccess, Error<UpdateUserGroupError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/user_groups/{user_group_id}", configuration.base_path, user_group_id=user_group_id);
    let mut local_var_req_builder = local_var_client.patch(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("name", &name.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("description", &description.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateUserGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update the members of a [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/{user_group_id}/members` 
pub async fn update_user_group_members(configuration: &configuration::Configuration, user_group_id: i32, delete: Option<Vec<i32>>, add: Option<Vec<i32>>) -> Result<crate::models::JsonSuccess, Error<UpdateUserGroupMembersError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/user_groups/{user_group_id}/members", configuration.base_path, user_group_id=user_group_id);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = delete {
        local_var_req_builder = local_var_req_builder.query(&[("delete", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = add {
        local_var_req_builder = local_var_req_builder.query(&[("add", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateUserGroupMembersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

