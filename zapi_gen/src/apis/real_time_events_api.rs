/*
 * Zulip REST API
 *
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `delete_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteQueueError {
    Status400(crate::models::BadEventQueueIdError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_events`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventsError {
    Status400(crate::models::BadEventQueueIdError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `real_time_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RealTimePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `register_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RegisterQueueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `rest_error_handling`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestErrorHandlingError {
    Status400(crate::models::OneOfInvalidApiKeyErrorMissingArgumentErrorUserNotAuthorizedError),
    UnknownValue(serde_json::Value),
}


/// Delete a previously registered queue.  `DELETE {{ api_url }}/v1/events` 
pub async fn delete_queue(configuration: &configuration::Configuration, queue_id: &str) -> Result<crate::models::JsonSuccess, Error<DeleteQueueError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/events", configuration.base_path);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("queue_id", &queue_id.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteQueueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// `GET {{ api_url }}/v1/events`  This endpoint allows you to receive new events from [a registered event queue](/api/register-queue). 
pub async fn get_events(configuration: &configuration::Configuration, queue_id: &str, last_event_id: Option<i32>, dont_block: Option<bool>) -> Result<crate::models::JsonSuccessBase, Error<GetEventsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/events", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("queue_id", &queue_id.to_string())]);
    if let Some(ref local_var_str) = last_event_id {
        local_var_req_builder = local_var_req_builder.query(&[("last_event_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dont_block {
        local_var_req_builder = local_var_req_builder.query(&[("dont_block", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetEventsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// (Ignored) 
pub async fn real_time_post(configuration: &configuration::Configuration, narrow: Option<Vec<Vec<String>>>, event_types: Option<Vec<String>>) -> Result<(), Error<RealTimePostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/real-time", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = narrow {
        local_var_req_builder = local_var_req_builder.query(&[("narrow", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = event_types {
        local_var_req_builder = local_var_req_builder.query(&[("event_types", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<RealTimePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This powerful endpoint can be used to register a Zulip \"event queue\" (subscribed to certain types of \"events\", or updates to the messages and other Zulip data the current user has access to), as well as to fetch the current state of that data. 
pub async fn register_queue(configuration: &configuration::Configuration, apply_markdown: Option<bool>, client_gravatar: Option<bool>, slim_presence: Option<bool>, event_types: Option<Vec<String>>, all_public_streams: Option<bool>, include_subscribers: Option<bool>, client_capabilities: Option<serde_json::Value>, fetch_event_types: Option<Vec<String>>, narrow: Option<Vec<Vec<String>>>) -> Result<crate::models::JsonSuccessBase, Error<RegisterQueueError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/register", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = apply_markdown {
        local_var_req_builder = local_var_req_builder.query(&[("apply_markdown", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = client_gravatar {
        local_var_req_builder = local_var_req_builder.query(&[("client_gravatar", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = slim_presence {
        local_var_req_builder = local_var_req_builder.query(&[("slim_presence", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = event_types {
        local_var_req_builder = local_var_req_builder.query(&[("event_types", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = all_public_streams {
        local_var_req_builder = local_var_req_builder.query(&[("all_public_streams", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_subscribers {
        local_var_req_builder = local_var_req_builder.query(&[("include_subscribers", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = client_capabilities {
        local_var_req_builder = local_var_req_builder.query(&[("client_capabilities", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fetch_event_types {
        local_var_req_builder = local_var_req_builder.query(&[("fetch_event_types", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = narrow {
        local_var_req_builder = local_var_req_builder.query(&[("narrow", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RegisterQueueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Common error to many endpoints 
pub async fn rest_error_handling(configuration: &configuration::Configuration, ) -> Result<(), Error<RestErrorHandlingError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/rest-error-handling", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<RestErrorHandlingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

