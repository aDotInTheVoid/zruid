/*
 * Zulip REST API
 *
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `create_big_blue_button_video_call`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateBigBlueButtonVideoCallError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_stream`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteStreamError {
    Status400(crate::models::JsonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_stream_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetStreamIdError {
    Status400(crate::models::CodedError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_stream_topics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetStreamTopicsError {
    Status400(crate::models::JsonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_streams`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetStreamsError {
    Status400(crate::models::CodedError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_subscription_status`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubscriptionStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_subscriptions`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubscriptionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `mute_topic`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MuteTopicError {
    Status400(crate::models::OneOfobjectobject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `subscribe`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubscribeError {
    Status400(crate::models::OneOfobjectobject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `unsubscribe`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnsubscribeError {
    Status400(crate::models::NonExistingStreamError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_stream`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateStreamError {
    Status400(crate::models::JsonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_subscription_settings`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSubscriptionSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_subscriptions`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSubscriptionsError {
    UnknownValue(serde_json::Value),
}


/// Create a video call URL for a Big Blue Button video call. Requires Big Blue Button to be configured on the Zulip server. 
pub async fn create_big_blue_button_video_call(configuration: &configuration::Configuration, ) -> Result<crate::models::JsonSuccessBase, Error<CreateBigBlueButtonVideoCallError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/calls/bigbluebutton/create", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateBigBlueButtonVideoCallError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// [Delete the stream](/help/delete-a-stream) with the ID `stream_id`.  `DELETE {{ api_url }}/v1/streams/{stream_id}` 
pub async fn delete_stream(configuration: &configuration::Configuration, stream_id: i32) -> Result<crate::models::JsonSuccess, Error<DeleteStreamError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/streams/{stream_id}", configuration.base_path, stream_id=stream_id);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteStreamError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the unique ID of a given stream.  `GET {{ api_url }}/v1/get_stream_id` 
pub async fn get_stream_id(configuration: &configuration::Configuration, stream: &str) -> Result<crate::models::JsonSuccessBase, Error<GetStreamIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/get_stream_id", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("stream", &stream.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetStreamIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all the topics in a specific stream  `GET {{ api_url }}/v1/users/me/{stream_id}/topics` 
pub async fn get_stream_topics(configuration: &configuration::Configuration, stream_id: i32) -> Result<crate::models::JsonSuccessBase, Error<GetStreamTopicsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/me/{stream_id}/topics", configuration.base_path, stream_id=stream_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetStreamTopicsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all streams that the user has access to.  `GET {{ api_url }}/v1/streams` 
pub async fn get_streams(configuration: &configuration::Configuration, include_public: Option<bool>, include_web_public: Option<bool>, include_subscribed: Option<bool>, include_all_active: Option<bool>, include_default: Option<bool>, include_owner_subscribed: Option<bool>) -> Result<crate::models::JsonSuccessBase, Error<GetStreamsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/streams", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_public {
        local_var_req_builder = local_var_req_builder.query(&[("include_public", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_web_public {
        local_var_req_builder = local_var_req_builder.query(&[("include_web_public", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_subscribed {
        local_var_req_builder = local_var_req_builder.query(&[("include_subscribed", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_all_active {
        local_var_req_builder = local_var_req_builder.query(&[("include_all_active", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_default {
        local_var_req_builder = local_var_req_builder.query(&[("include_default", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_owner_subscribed {
        local_var_req_builder = local_var_req_builder.query(&[("include_owner_subscribed", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetStreamsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Check whether a user is subscribed to a stream.  `GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}`  **Changes**: New in Zulip 3.0 (feature level 11). 
pub async fn get_subscription_status(configuration: &configuration::Configuration, user_id: i32, stream_id: i32) -> Result<crate::models::JsonSuccessBase, Error<GetSubscriptionStatusError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/{user_id}/subscriptions/{stream_id}", configuration.base_path, user_id=user_id, stream_id=stream_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSubscriptionStatusError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all streams that the user is subscribed to.  `GET {{ api_url }}/v1/users/me/subscriptions` 
pub async fn get_subscriptions(configuration: &configuration::Configuration, include_subscribers: Option<bool>) -> Result<crate::models::JsonSuccessBase, Error<GetSubscriptionsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/me/subscriptions", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_subscribers {
        local_var_req_builder = local_var_req_builder.query(&[("include_subscribers", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetSubscriptionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user's unread count totals.  `PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics` 
pub async fn mute_topic(configuration: &configuration::Configuration, topic: &str, op: &str, stream: Option<&str>, stream_id: Option<i32>) -> Result<crate::models::JsonSuccess, Error<MuteTopicError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/me/subscriptions/muted_topics", configuration.base_path);
    let mut local_var_req_builder = local_var_client.patch(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = stream {
        local_var_req_builder = local_var_req_builder.query(&[("stream", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = stream_id {
        local_var_req_builder = local_var_req_builder.query(&[("stream_id", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("topic", &topic.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("op", &op.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<MuteTopicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Subscribe one or more users to one or more streams.  `POST {{ api_url }}/v1/users/me/subscriptions`  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like `invite_only` detailed below. 
pub async fn subscribe(configuration: &configuration::Configuration, subscriptions: Vec<serde_json::Value>, principals: Option<Vec<crate::models::OneOfstringinteger>>, authorization_errors_fatal: Option<bool>, announce: Option<bool>, invite_only: Option<bool>, history_public_to_subscribers: Option<bool>, stream_post_policy: Option<i32>, message_retention_days: Option<crate::models::OneOfstringinteger>) -> Result<crate::models::OneOfobjectobject, Error<SubscribeError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/me/subscriptions", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("subscriptions", &subscriptions.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    if let Some(ref local_var_str) = principals {
        local_var_req_builder = local_var_req_builder.query(&[("principals", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = authorization_errors_fatal {
        local_var_req_builder = local_var_req_builder.query(&[("authorization_errors_fatal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = announce {
        local_var_req_builder = local_var_req_builder.query(&[("announce", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = invite_only {
        local_var_req_builder = local_var_req_builder.query(&[("invite_only", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = history_public_to_subscribers {
        local_var_req_builder = local_var_req_builder.query(&[("history_public_to_subscribers", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = stream_post_policy {
        local_var_req_builder = local_var_req_builder.query(&[("stream_post_policy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = message_retention_days {
        local_var_req_builder = local_var_req_builder.query(&[("message_retention_days", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SubscribeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Unsubscribe yourself or other users from one or more streams.  `DELETE {{ api_url }}/v1/users/me/subscriptions` 
pub async fn unsubscribe(configuration: &configuration::Configuration, subscriptions: Vec<String>, principals: Option<Vec<crate::models::OneOfstringinteger>>) -> Result<crate::models::JsonSuccessBase, Error<UnsubscribeError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/me/subscriptions", configuration.base_path);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("subscriptions", &subscriptions.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    if let Some(ref local_var_str) = principals {
        local_var_req_builder = local_var_req_builder.query(&[("principals", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UnsubscribeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Configure the stream with the ID `stream_id`.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  `PATCH {{ api_url }}/v1/streams/{stream_id}` 
pub async fn update_stream(configuration: &configuration::Configuration, stream_id: i32, description: Option<&str>, new_name: Option<&str>, is_private: Option<bool>, is_announcement_only: Option<bool>, stream_post_policy: Option<i32>, history_public_to_subscribers: Option<bool>, message_retention_days: Option<crate::models::OneOfstringinteger>) -> Result<crate::models::JsonSuccess, Error<UpdateStreamError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/streams/{stream_id}", configuration.base_path, stream_id=stream_id);
    let mut local_var_req_builder = local_var_client.patch(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = description {
        local_var_req_builder = local_var_req_builder.query(&[("description", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = new_name {
        local_var_req_builder = local_var_req_builder.query(&[("new_name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_private {
        local_var_req_builder = local_var_req_builder.query(&[("is_private", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_announcement_only {
        local_var_req_builder = local_var_req_builder.query(&[("is_announcement_only", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = stream_post_policy {
        local_var_req_builder = local_var_req_builder.query(&[("stream_post_policy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = history_public_to_subscribers {
        local_var_req_builder = local_var_req_builder.query(&[("history_public_to_subscribers", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = message_retention_days {
        local_var_req_builder = local_var_req_builder.query(&[("message_retention_days", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateStreamError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint is used to update the user's personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  `POST {{ api_url }}/v1/users/me/subscriptions/properties` 
pub async fn update_subscription_settings(configuration: &configuration::Configuration, subscription_data: Vec<serde_json::Value>) -> Result<crate::models::JsonSuccessBase, Error<UpdateSubscriptionSettingsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/me/subscriptions/properties", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("subscription_data", &subscription_data.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateSubscriptionSettingsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update which streams you are are subscribed to. 
pub async fn update_subscriptions(configuration: &configuration::Configuration, delete: Option<Vec<String>>, add: Option<Vec<serde_json::Value>>) -> Result<crate::models::JsonSuccessBase, Error<UpdateSubscriptionsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/me/subscriptions", configuration.base_path);
    let mut local_var_req_builder = local_var_client.patch(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = delete {
        local_var_req_builder = local_var_req_builder.query(&[("delete", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = add {
        local_var_req_builder = local_var_req_builder.query(&[("add", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateSubscriptionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

